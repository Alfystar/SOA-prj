\section{Introduzione}

Lo scopo del sistema è di mettere in cominicazione un numero imprecisato di processi all'interno dello stesso kernel, e
permettere lo scambio istanteneo di pacchetti tra 1 \Writer e i \Reader in attesa su di un canale.

La comunicazione viene svolta nel minor tempo possibile e adottando un algorimo \textit{Semi-Lock Free}

Il comportamento desiderato è che l'arrivo di 1-\Writer che scrive su di un canale, porta al risveglio degli n-\Reader
precedentemente in attesa sullo stesso, il tutto nel minor tempo possibile.

Il canale di comunicazione è definito su 2 livelli di ricerca:
\begin{enumerate}
    \item \textbf{Tag-level search} \\
    Stanze effettivamente instanziate nel sistema, di default ne possono esistere fino a 256,
    ma è possibile variare a \RunTime questo limite facendolo crescere a piacere, o decrescere fino al
    numero di stanze attualmente aperto, e comunque non meno di 256 \textbf{nell'implementazione di questo progetto}.
    \item \textbf{Topic-level} \\
    Ogni stanza, possiede a sua volta 32 sotto livelli dove effettivamente i \Reader  e \Writer  parlano
\end{enumerate}

Segue che nella stessa stanza(\tagSys) è possibile svolgere in parallelo più conversazioni, e far accodare
diversi thread su diversi topic, fino al limite di 32 \textit{topic} per stanza.

Le stanze possono essere pubbliche, e in tal caso gli si associa una \keySys, o private, e in tal caso la \tagSys è
nota solo a chi ha creato la stanza.

Per interagire con il sistema sono state implementate 4 system-call "rubate" alla sys-call table dalle funzioni che
puntavano alla \verb|sys_ni_syscall|, ovvero quelle ancora implementate nel kernel.

\begin{enumerate}
    \item \verb|int tag_get(int key, int command, int permission)|\\
    Per me mezzo di questa sys-call è possibile creare una stanza publica o privata (permission)
    rispetto ai thread di altri processi, e scegliere se deve essere indicizzata globalmente o meno (key)
    \item \verb|int tag_send(int tag, int level, char* buffer, size_t size)|\\
    Questa sys-call permette a un \Writer di publicare nella stanza desiderata al livello voluto
    \item \verb|int tag_receive(int tag, int level, char* buffer, size_t size)|\\
    Questa sys-call mette un \Reader in attesa nella stanza al livello voluto finchè un \Writer non la risveglia
    \item \verb|int tag_ctl(int tag, int command)|\\
    Con quest'ultima syscall è possibile inviare dei comandi all'intera stanza, nella fattispecie la chiusura e la
wake-up-all
\end{enumerate}
Per avere più dettagli sulle richieste delle interfacce si faccia riferimento alla pagina ufficiale del progetto:
\href{https://francescoquaglia.github.io/TEACHING/AOS/PROJECTS/project-specification-2020-2021.html}{SOA-prg}

\textbf{In aggiunta alle richieste del progetto}, questa implementazione ha la possibilità di modificare a
\RunTime il numero di di Stanze massime del sistema, facendolo crescere a piacere, e ridurre fino al numero minimo di
256, senza però scendere sotto il numero di stanze correntemente allocate.


Viene anche fornita la libreria \texttt{user-space} che permette di trovare autonomamente i numeri delle syscall, e
implementa un \texttt{perror} standard per ciascuna delle 4 syscall.
